

/*! terminal.js v2.0 | (c) 2014 Erik Ã–sterberg | https://github.com/eosterberg/terminaljs */

var Terminal = (function () {
	// PROMPT_TYPE
	var PROMPT_INPUT = 1, PROMPT_PASSWORD = 2, PROMPT_CONFIRM = 3

	var fireCursorInterval = function (inputField, terminalObj) {
		var cursor = terminalObj._cursor
		setTimeout(function () {
			if (inputField.parentElement && terminalObj._shouldBlinkCursor) {
				cursor.style.visibility = cursor.style.visibility === 'visible' ? 'hidden' : 'visible'
				fireCursorInterval(inputField, terminalObj)
			} else {
				cursor.style.visibility = 'visible'
			}
		}, 500)
	}

	var firstPrompt = true;
	promptInput = function (terminalObj, message, PROMPT_TYPE, callback) {
		var shouldDisplayInput = (PROMPT_TYPE === PROMPT_INPUT)
		var inputField = document.createElement('input')

		inputField.style.position = 'absolute'
		inputField.style.zIndex = '-100'
		inputField.style.outline = 'none'
		inputField.style.border = 'none'
		inputField.style.opacity = '0'
		inputField.style.fontSize = '0.2em'

		terminalObj._inputLine.textContent = ''
		terminalObj._input.style.display = 'block'
		terminalObj.html.appendChild(inputField)
		fireCursorInterval(inputField, terminalObj)

		if (message.length) terminalObj.print(PROMPT_TYPE === PROMPT_CONFIRM ? message + ' (y/n)' : message)

		inputField.onblur = function () {
			terminalObj._cursor.style.display = 'none'
		}

		inputField.onfocus = function () {
			inputField.value = terminalObj._inputLine.textContent
			terminalObj._cursor.style.display = 'inline'
		}

		terminalObj.html.onclick = function () {
			inputField.focus()
		}

		inputField.onkeydown = function (e) {
			if (e.which === 37 || e.which === 39 || e.which === 38 || e.which === 40 || e.which === 9) {
				e.preventDefault()
			} else if (shouldDisplayInput && e.which !== 13) {
				setTimeout(function () {
					terminalObj._inputLine.textContent = inputField.value
				}, 1)
			}
		}
		inputField.onkeyup = function (e) {
			if (PROMPT_TYPE === PROMPT_CONFIRM || e.which === 13) {
				terminalObj._input.style.display = 'none'
				var inputValue = inputField.value
				if (shouldDisplayInput) terminalObj.print(inputValue)
				terminalObj.html.removeChild(inputField)
				if (typeof(callback) === 'function') {
					if (PROMPT_TYPE === PROMPT_CONFIRM) {
						callback(inputValue.toUpperCase()[0] === 'Y' ? true : false)
					} else callback(inputValue)
				}
			}
		}
		if (firstPrompt) {
			firstPrompt = false
			setTimeout(function () { inputField.focus()	}, 50)
		} else {
			inputField.focus()
		}
	}

	var terminalBeep

	var TerminalConstructor = function (id) {
		if (false) {
			terminalBeep = document.createElement('audio')
			var source = '<source src="http://www.erikosterberg.com/terminaljs/beep.'
			terminalBeep.innerHTML = source + 'mp3" type="audio/mpeg">' + source + 'ogg" type="audio/ogg">'
			terminalBeep.volume = 0.05
		}

		this.html = document.createElement('div')
		this.html.className = 'Terminal'
		if (typeof(id) === 'string') { this.html.id = id }

		this._innerWindow = document.createElement('div')
		this._output = document.createElement('p')
		this._inputLine = document.createElement('span') //the span element where the users input is put
		this._cursor = document.createElement('span')
		this._input = document.createElement('p') //the full element administering the user input, including cursor

		this._shouldBlinkCursor = true

		this.beep = function () {
			terminalBeep.load()
			terminalBeep.play()
		}

		this.print = function (message) {
			var newLine = document.createElement('div')
			newLine.innerHTML = message
			this._output.appendChild(newLine)
		}

		this.input = function (message, callback) {
			promptInput(this, message, PROMPT_INPUT, callback)
		}

		this.password = function (message, callback) {
			promptInput(this, message, PROMPT_PASSWORD, callback)
		}

		this.confirm = function (message, callback) {
			promptInput(this, message, PROMPT_CONFIRM, callback)
		}

		this.clear = function () {
			this._output.innerHTML = ''
		}

		this.sleep = function (milliseconds, callback) {
			setTimeout(callback, milliseconds)
		}

		this.setTextSize = function (size) {
			this._output.style.fontSize = size
			this._input.style.fontSize = size
		}

		this.setTextColor = function (col) {
			this.html.style.color = col
			this._cursor.style.background = col
		}

		this.setBackgroundColor = function (col) {
			this.html.style.background = col
		}

		this.setWidth = function (width) {
			this.html.style.width = width
		}

		this.setHeight = function (height) {
			this.html.style.height = height
		}

		this.blinkingCursor = function (bool) {
			bool = bool.toString().toUpperCase()
			this._shouldBlinkCursor = (bool === 'TRUE' || bool === '1' || bool === 'YES')
		}

		this._input.appendChild(this._inputLine)
		this._input.appendChild(this._cursor)
		this._innerWindow.appendChild(this._output)
		this._innerWindow.appendChild(this._input)
		this.html.appendChild(this._innerWindow)

		this.html.style.position = "fixed"
		this.html.style.bottom = "0px"
		this.html.style.overflow = "scroll"

		this.setBackgroundColor('#e2007f')
		this.setTextColor('rgb(255, 235, 59)')
		this.setTextSize('1em')
		this.setWidth('100%')
		this.setHeight('100%')

		this.html.style.fontFamily = 'Monaco, Courier'
		this.html.style.margin = '0'
		this._innerWindow.style.padding = '10px'
		this._input.style.margin = '0'
		this._output.style.margin = '0'
		this._cursor.style.background = 'white'
		this._cursor.innerHTML = 'C' //put something in the cursor..
		this._cursor.style.display = 'none' //then hide it
		this._input.style.display = 'none'
	}

	return TerminalConstructor
}());





(function() {
	if (typeof Methone === undefined) {
		console.error("Must be loaded after methone!");
		return;
	}

	/**
	 * The Dispatcher allows code to hook in commands.
	 */
	var Dispatcher = (function() {

		var parseCommand = function(command) {
			var regex = /[^\s"]+|"([^"]*)"/gi;
			var output = [];

			do {
			    var match = regex.exec(command);
			    if (match != null)
			    {
			        output.push(match[1] ? match[1] : match[0]);
			    }
			} while (match != null);
			return output;
		}

		var Constructor = function(term) {
			if (term == null) {
				console.error("Null term");
				return 0;
			}
			var _dict = {};
			var _this = this;

			var dispatch = function(text) {
				var cmd = parseCommand(text);
				console.log("dispatch " + cmd);
				try {
					_dict[cmd[0]](cmd, term, _dict);
				} catch (e) {
					term.print("Unknown command");
				} finally {
					_this.awaitInput();
				}
			}

			this.awaitInput = function() {
				term.input("", dispatch);
			};

			this.register = function(cmd, callback) {
				_dict[cmd] = callback;
			}
		}

		return Constructor;
	})();

	var JsonRpc = (function() {
		var req_count = 0;

		var makeRequest = function(url, data, callback, error_callback) {

			var r = new XMLHttpRequest();
			r.open("POST", url, true);
			r.setRequestHeader("Content-Type", "application/json");
			r.onreadystatechange = function () {
			  if (r.readyState != 4) return;
				if(r.status != 200) {
					error_callback(r);
					return;
				}

				callback(r.responseText);
			};
			r.send(data);
		}

		var Constructor = function(dispatch) {
			var isValid = false;


			var send = function(cmd, xterm) {
				if (!isValid) {
					console.log("Error: rpc module is invalid");
					return -1;
				}

				var message = {
					jsonrpc: "2.0",
					method: cmd[1],
					params: cmd.slice(2),
					id: ++req_count
				};

				makeRequest(Methone.conf.json_rpc_api_url, JSON.stringify(message), function(data) {
					xterm.print(data);
				}, function(r) {
					xterm.print("RPC Error: " + r.status + " " + r.responseText);
				});

				return req_count;
			}

			dispatch.register("rpc", function(cmd, xterm) {
				if (!isValid) {
					xterm.print("RPC is not configured for this site");
				} else {
					send(cmd, xterm);
				}

			});

			if (Methone.conf.json_rpc_api_url)
				isValid = true;
		};
		return Constructor;
	})();



	var term = new Terminal();
	var dispatch = new Dispatcher(term);
	var rpc = new JsonRpc(dispatch);

	Methone._terminal = term;
	Methone.dispatch = dispatch;

	document.body.appendChild(term.html);

	term.setHeight("200px")
	term.print("Welcome to Methone shell on " + window.location.hostname);

	var do_print_log = false;
	console._l = console.log;
	console.log = function (text) {
		console._l(text);
		if (do_print_log)
			term.print("Logged: " + text);
	}


	dispatch.register("help", function(cmd, xterm, dict) {
		term.print("Welcome to Methone Shell");
		term.print("Known commands:");
		for (var key in dict) {
		  if (dict.hasOwnProperty(key)) {
		    term.print("&emsp;"+key);
		  }
		}
	});

	dispatch.register("loglevel", function(cmd, xterm) {
		if (cmd.length < 2) {
			xterm.print("Usage: loglevel on|off")
			return;
		}

		switch (cmd[1]) {
			case "on":
			case "y":
			case "1":
				do_print_log = true;
				break;
			case "off":
			case "n":
			case "0":
				do_print_log = false;
				break;
			default:
				xterm.print("Valid values are on/off");
		}
	})

	dispatch.awaitInput();

})();
